import HTML5Tokenizer from './simple-html-tokenizer';
import * as linkify from './linkify';

const options = linkify.options;
const StartTag = 'StartTag';
const EndTag = 'EndTag';
const Chars = 'Chars';
const Comment = 'Comment';

/**
	`tokens` and `token` in this section refer to tokens generated by the HTML
	parser.
*/
export default function linkifyHtml(str, opts={}) {
	let tokens = HTML5Tokenizer.tokenize(str);
	let linkifiedTokens = [];
	let linkified = [];
	var i;

	opts = linkify.options.normalize(opts);

	// Linkify the tokens given by the parser
	for (i = 0; i < tokens.length; i++) {
		let token = tokens[i];

		if (token.type === StartTag) {
			linkifiedTokens.push(token);

			// Ignore all the contents of ignored tags
			let tagName = token.tagName.toUpperCase();
			let isIgnored = tagName === 'A' ||
				options.contains(opts.ignoreTags, tagName);
			if (!isIgnored) continue;

			let preskipLen = linkifiedTokens.length;
			skipTagTokens(tagName, tokens, ++i, linkifiedTokens);
			i += linkifiedTokens.length - preskipLen - 1;
			continue;

		} else if (token.type !== Chars) {
			// Skip this token, it's not important
			linkifiedTokens.push(token);
			continue;
		}

		// Valid text token, linkify it!
		let linkifedChars = linkifyChars(token.chars, opts);
		linkifiedTokens.push.apply(linkifiedTokens, linkifedChars);
	}

	// Convert the tokens back into a string
	for (i = 0; i < linkifiedTokens.length; i++) {
		let token = linkifiedTokens[i];
		switch (token.type) {
		case StartTag:
			let attrs = attrsToStrings(token.attributes);
			let link = '<' + token.tagName;
			if (attrs.length > 0) { link += ' ' + attrs.join(' '); }
			link += '>';
			linkified.push(link);
			break;
		case EndTag:
			linkified.push(`</${token.tagName}>`);
			break;
		case Chars:
			linkified.push(escapeText(token.chars));
			break;
		case Comment:
			linkified.push(`<!--${escapeText(token.chars)}-->`);
			break;
		}
	}

	return linkified.join('');
}

/**
	`tokens` and `token` in this section referes to tokens returned by
	`linkify.tokenize`. `linkified` will contain HTML Parser-style tokens
*/
function linkifyChars(str, opts) {
	let tokens = linkify.tokenize(str);
	let result = [];

	for (var i = 0; i < tokens.length; i++) {
		let token = tokens[i];
		let validated = token.isLink && linkify.options.resolve(opts.validate, token.toString(), token.type);

		if (token.type === 'nl' && opts.nl2br) {
			result.push({
				type: StartTag,
				tagName: 'br',
				attributes: [],
				selfClosing: true
			});
			continue;
		} else if (!token.isLink || !validated) {
			result.push({type: Chars, chars: token.toString()});
			continue;
		}

		let href			= token.toHref(opts.defaultProtocol);
		let formatted		= linkify.options.resolve(opts.format, token.toString(), token.type);
		let formattedHref	= linkify.options.resolve(opts.formatHref, href, token.type);
		let attributesHash	= linkify.options.resolve(opts.attributes, href, token.type);
		let tagName			= linkify.options.resolve(opts.tagName, href, token.type);
		let linkClass		= linkify.options.resolve(opts.linkClass, href, token.type);
		let target			= linkify.options.resolve(opts.target, href, token.type);

		// Build up attributes
		let attributes = [
			['href', formattedHref],
			['class', linkClass]
		];

		if (target) {
			attributes.push(['target', target]);
		}

		for (var attr in attributesHash) {
			attributes.push([attr, attributesHash[attr]]);
		}

		// Add the required tokens
		result.push({
			type: StartTag,
			tagName: tagName,
			attributes: attributes,
			selfClosing: false
		});
		result.push({type: Chars, chars: formatted});
		result.push({type: EndTag, tagName: tagName});
	}

	return result;
}

/**
	Returns a list of tokens skipped until the closing tag of tagName.

	* `tagName` is the closing tag which will prompt us to stop skipping
	* `tokens` is the array of tokens generated by HTML5Tokenizer which
	* `i` is the index immediately after the opening tag to skip
	* `skippedTokens` is an array which skipped tokens are being pushed into

	Caveats

	* Assumes that i is the first token after the given opening tagName
	* The closing tag will be skipped, but nothing after it
	* Will track whether there is a nested tag of the same type
*/
function skipTagTokens(tagName, tokens, i, skippedTokens) {

	// number of tokens of this type on the [fictional] stack
	var stackCount = 1;

	while (i < tokens.length && stackCount > 0) {
		let token = tokens[i];
		if (token.type === StartTag && token.tagName.toUpperCase() === tagName) {
			// Nested tag of the same type, "add to stack"
			stackCount++;
		} else if (token.type === EndTag && token.tagName.toUpperCase() === tagName) {
			// Closing tag
			stackCount--;
		}
		skippedTokens.push(token);
		i++;
	}

	// Note that if stackCount > 0 here, the HTML is probably invalid
	return skippedTokens;
}

function escapeText(text) {
	// Not required, HTML tokenizer ensures this occurs properly
	return text;
}

function escapeAttr(attr) {
	return attr.replace(/"/g, '&quot;');
}

function attrsToStrings(attrs) {
	let attrStrs = [];
	for (let i = 0; i < attrs.length; i++) {
		let [name, value] = attrs[i];
		attrStrs.push(`${name}="${escapeAttr(value)}"`);
	}
	return attrStrs;
}
