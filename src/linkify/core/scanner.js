/**
	The scanner provides an interface that takes a string of text as input, and
	outputs an array of tokens instances that can be used for easy URL parsing.

	@module linkify
	@submodule scanner
	@main scanner
*/
import {
	makeState,
	makeAcceptingState,
	takeT,
	makeT,
	makeRegexT,
	makeMultiT,
	makeBatchT,
	makeChainT
} from './fsm';
import * as tk from './tokens/text';
import tlds from './tlds';

// Note that these two Unicode ones expand into a really big one with Babel
export const LETTER = /\p{L}/u; // Any Unicode character with letter data type
export const EMOJI = /\p{Emoji}/u; // Any Unicode emoji character
export const DIGIT = /\d/;
export const SPACE = /\s/;

/**
 * Initialize the scanner character-based state machine for the given start state
 * @return {State} scanner starting state
 */
export function init() {
	// Frequently used states
	const S_START = makeState();
	const S_NUM				= makeAcceptingState(tk.NUM);
	const S_DOMAIN			= makeAcceptingState(tk.DOMAIN);
	const S_DOMAIN_HYPHEN	= makeState(); // domain followed by 1 or more hyphen characters
	const S_WS				= makeAcceptingState(tk.WS);

	const DOMAIN_REGEX_TRANSITIONS = [
		[DIGIT, S_DOMAIN],
		[LETTER, S_DOMAIN],
		[EMOJI, S_DOMAIN]
	];

	// Create a state which emits a domain token
	const makeDomainState = () => {
		const state = makeAcceptingState(tk.DOMAIN);
		state.j = {'-': S_DOMAIN_HYPHEN };
		state.jr = [...DOMAIN_REGEX_TRANSITIONS];
		return state;
	};

	// Create a state which does not emit a domain state but the usual alphanumeric
	// transitions are domains
	const makeNearDomainState = (token) => {
		const state = makeDomainState();
		state.t = token;
		return state;
	};

	// States for special URL symbols that accept immediately after start
	makeBatchT(S_START, [
		['@', makeAcceptingState(tk.AT)],
		['.', makeAcceptingState(tk.DOT)],
		['+', makeAcceptingState(tk.PLUS)],
		['#', makeAcceptingState(tk.POUND)],
		['?', makeAcceptingState(tk.QUERY)],
		['/', makeAcceptingState(tk.SLASH)],
		['_', makeAcceptingState(tk.UNDERSCORE)],
		[':', makeAcceptingState(tk.COLON)],
		['{', makeAcceptingState(tk.OPENBRACE)],
		['[', makeAcceptingState(tk.OPENBRACKET)],
		['<', makeAcceptingState(tk.OPENANGLEBRACKET)],
		['(', makeAcceptingState(tk.OPENPAREN)],
		['}', makeAcceptingState(tk.CLOSEBRACE)],
		[']', makeAcceptingState(tk.CLOSEBRACKET)],
		['>', makeAcceptingState(tk.CLOSEANGLEBRACKET)],
		[')', makeAcceptingState(tk.CLOSEPAREN)],
		['&', makeAcceptingState(tk.AMPERSAND)]
	]);

	makeMultiT(S_START, [',', ';', '!', '"', '\''], makeAcceptingState(tk.PUNCTUATION));

	// Whitespace jumps
	// Tokens of only non-newline whitespace are arbitrarily long
	makeT(S_START, '\n', makeAcceptingState(tk.NL));
	makeRegexT(S_START, SPACE, S_WS);

	// If any whitespace except newline, more whitespace!
	makeT(S_WS, '\n', makeState()); // non-accepting state
	makeRegexT(S_WS, SPACE, S_WS);

	// Generates states for top-level domains
	// Note that this is most accurate when tlds are in alphabetical order
	for (let i = 0; i < tlds.length; i++) {
		makeChainT(S_START, tlds[i], makeNearDomainState(tk.TLD), makeDomainState);
	}

	// Collect the states generated by different protocls
	const S_PROTOCOL_FILE = makeDomainState();
	const S_PROTOCOL_FTP = makeDomainState();
	const S_PROTOCOL_HTTP = makeDomainState();
	const S_MAILTO = makeDomainState();
	makeChainT(S_START, 'file', S_PROTOCOL_FILE, makeDomainState);
	makeChainT(S_START, 'ftp', S_PROTOCOL_FTP, makeDomainState);
	makeChainT(S_START, 'http', S_PROTOCOL_HTTP, makeDomainState);
	makeChainT(S_START, 'mailto', S_MAILTO, makeDomainState);

	// Protocol states
	const S_PROTOCOL_SECURE = makeDomainState();
	const S_FULL_PROTOCOL = makeAcceptingState(tk.PROTOCOL); // Full protocol ends with COLON
	const S_FULL_MAILTO = makeAcceptingState(tk.MAILTO); // Mailto ends with COLON

	// Secure protocols (end with 's')
	makeT(S_PROTOCOL_FTP, 's', S_PROTOCOL_SECURE);
	makeT(S_PROTOCOL_FTP, ':', S_FULL_PROTOCOL);
	makeT(S_PROTOCOL_HTTP, 's', S_PROTOCOL_SECURE);
	makeT(S_PROTOCOL_HTTP, ':', S_FULL_PROTOCOL);

	// Become protocol tokens after a COLON
	makeT(S_PROTOCOL_FILE, ':', S_FULL_PROTOCOL);
	makeT(S_PROTOCOL_SECURE, ':', S_FULL_PROTOCOL);
	makeT(S_MAILTO, ':', S_FULL_MAILTO);

	// Localhost
	makeChainT(S_START, 'localhost', makeNearDomainState(tk.LOCALHOST), makeDomainState);

	// Everything else
	// DOMAINs make more DOMAINs
	// Number and character transitions
	makeRegexT(S_START, DIGIT, S_NUM);
	makeRegexT(S_START, LETTER, S_DOMAIN);
	makeRegexT(S_START, EMOJI, S_DOMAIN);
	makeRegexT(S_NUM, DIGIT, S_NUM);
	makeRegexT(S_NUM, LETTER, S_DOMAIN); // number becomes DOMAIN
	makeRegexT(S_NUM, EMOJI, S_DOMAIN); // number becomes DOMAIN
	makeT(S_NUM, '-', S_DOMAIN_HYPHEN);

	// Default domain transitions
	makeT(S_DOMAIN, '-', S_DOMAIN_HYPHEN);
	makeT(S_DOMAIN_HYPHEN, '-', S_DOMAIN_HYPHEN);
	makeRegexT(S_DOMAIN, DIGIT, S_DOMAIN);
	makeRegexT(S_DOMAIN, LETTER, S_DOMAIN);
	makeRegexT(S_DOMAIN, EMOJI, S_DOMAIN);
	makeRegexT(S_DOMAIN_HYPHEN, DIGIT, S_DOMAIN);
	makeRegexT(S_DOMAIN_HYPHEN, LETTER, S_DOMAIN);
	makeRegexT(S_DOMAIN_HYPHEN, EMOJI, S_DOMAIN);

	// Set default transition for start state (some symbol)
	S_START.jd = makeAcceptingState(tk.SYM);
	return S_START;
}

/**
	Given a string, returns an array of TOKEN instances representing the
	composition of that string.

	@method run
	@param {State} start scanner starting state
	@param {string} str input string to scan
	@return {Array<{t: string, v: string, s: number, l: number}>} list of tokens, each with a type and value
*/
export function run(start, str) {
	// State machine is not case sensitive, so input is tokenized in lowercased
	// form (still returns the regular case though) Uses selective `toLowerCase`
	// is used because lowercasing the entire string causes the length and
	// character position to vary in some non-English strings with V8-based
	// runtimes.
	const iterable = Array.from(str.replace(/[A-Z]/g, (c) => c.toLowerCase()));
	const charCount = iterable.length; // <= len if there are emojis, etc
	const tokens = []; // return value

	// cursor through the string itself, accounting for characters that have
	// width with length 2 such as emojis
	let cursor = 0;

	// Cursor through the array-representation of the string
	let charCursor = 0;

	// Tokenize the string
	while (charCursor < charCount) {
		let state = start;
		let nextState = null;
		let tokenLength = 0;
		let latestAccepting = null;
		let sinceAccepts = -1;
		let charsSinceAccepts = -1;

		while (charCursor < charCount && (nextState = takeT(state, iterable[charCursor]))) {
			state = nextState;

			// Keep track of the latest accepting state
			if (state.accepts()) {
				sinceAccepts = 0;
				charsSinceAccepts = 0;
				latestAccepting = state;
			} else if (sinceAccepts >= 0) {
				sinceAccepts += iterable[charCursor].length;
				charsSinceAccepts++;
			}

			tokenLength += iterable[charCursor].length;
			cursor += iterable[charCursor].length;
			charCursor++;
		}

		if (sinceAccepts < 0) { continue; } // Should never happen

		// Roll back to the latest accepting state
		cursor -= sinceAccepts;
		charCursor -= charsSinceAccepts;
		tokenLength -= sinceAccepts;

		// No more jumps, just make a new token from the last accepting one
		// TODO: If possible, don't output v, instead output range where values ocur
		tokens.push({
			t: latestAccepting.t, // token type/name
			v: str.substr(cursor - tokenLength, tokenLength), // string value
			s: cursor - tokenLength, // start index
			e: cursor // end index (excluding)
		});
	}

	return tokens;
}

export { tk as tokens };
