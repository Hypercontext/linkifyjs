/**
	The scanner provides an interface that takes a string of text as input, and
	outputs an array of tokens instances that can be used for easy URL parsing.

	@module linkify
	@submodule scanner
	@main scanner
*/
import {
	makeState,
	makeAcceptingState,
	takeT,
	makeT,
	makeRegexT,
	makeBatchT,
	makeChainT
} from './fsm';
import * as tk from './tokens/text';
import tlds from './tlds';

// Note that these two Unicode ones expand into a really big one with Babel
export const LETTER = /\p{L}/u; // Any Unicode character with letter data type
export const EMOJI = /\p{Emoji}/u; // Any Unicode emoji character
export const EMOJI_VARIATION = /\uFE0F/; // Variation selector, follows heart and others
export const DIGIT = /\d/;
export const SPACE = /\s/;

/**
 * Initialize the scanner character-based state machine for the given start state
 * @return {State} scanner starting state
 */
export function init(customProtocols = []) {
	// Frequently used states
	const S_START = makeState();
	const S_NUM				= makeAcceptingState(tk.NUM);
	const S_DOMAIN			= makeAcceptingState(tk.DOMAIN);
	const S_DOMAIN_HYPHEN	= makeState(); // domain followed by 1 or more hyphen characters
	const S_WS				= makeAcceptingState(tk.WS);

	const DOMAIN_REGEX_TRANSITIONS = [
		[DIGIT, S_DOMAIN],
		[LETTER, S_DOMAIN],
		[EMOJI, S_DOMAIN],
		[EMOJI_VARIATION, S_DOMAIN]
	];

	// Create a state which emits a domain token
	const makeDomainState = () => {
		const state = makeAcceptingState(tk.DOMAIN);
		state.j = {'-': S_DOMAIN_HYPHEN };
		state.jr = [...DOMAIN_REGEX_TRANSITIONS];
		return state;
	};

	// Create a state which does not emit a domain state but the usual alphanumeric
	// transitions are domains
	const makeNearDomainState = (token) => {
		const state = makeDomainState();
		state.t = token;
		return state;
	};

	// States for special URL symbols that accept immediately after start
	makeBatchT(S_START, [
		["'", makeAcceptingState(tk.APOSTROPHE)],
		['{', makeAcceptingState(tk.OPENBRACE)],
		['[', makeAcceptingState(tk.OPENBRACKET)],
		['<', makeAcceptingState(tk.OPENANGLEBRACKET)],
		['(', makeAcceptingState(tk.OPENPAREN)],
		['}', makeAcceptingState(tk.CLOSEBRACE)],
		[']', makeAcceptingState(tk.CLOSEBRACKET)],
		['>', makeAcceptingState(tk.CLOSEANGLEBRACKET)],
		[')', makeAcceptingState(tk.CLOSEPAREN)],
		['&', makeAcceptingState(tk.AMPERSAND)],
		['*', makeAcceptingState(tk.ASTERISK)],
		['@', makeAcceptingState(tk.AT)],
		['`', makeAcceptingState(tk.BACKTICK)],
		['^', makeAcceptingState(tk.CARET)],
		[':', makeAcceptingState(tk.COLON)],
		[',', makeAcceptingState(tk.COMMA)],
		['$', makeAcceptingState(tk.DOLLAR)],
		['.', makeAcceptingState(tk.DOT)],
		['=', makeAcceptingState(tk.EQUALS)],
		['!', makeAcceptingState(tk.EXCLAMATION)],
		['-', makeAcceptingState(tk.HYPHEN)],
		['%', makeAcceptingState(tk.PERCENT)],
		['|', makeAcceptingState(tk.PIPE)],
		['+', makeAcceptingState(tk.PLUS)],
		['#', makeAcceptingState(tk.POUND)],
		['?', makeAcceptingState(tk.QUERY)],
		['"', makeAcceptingState(tk.QUOTE)],
		['/', makeAcceptingState(tk.SLASH)],
		[';', makeAcceptingState(tk.SEMI)],
		['~', makeAcceptingState(tk.TILDE)],
		['_', makeAcceptingState(tk.UNDERSCORE)],
		['\\', makeAcceptingState(tk.BACKSLASH)]
	]);

	// Whitespace jumps
	// Tokens of only non-newline whitespace are arbitrarily long
	makeT(S_START, '\n', makeAcceptingState(tk.NL));
	makeRegexT(S_START, SPACE, S_WS);

	// If any whitespace except newline, more whitespace!
	makeT(S_WS, '\n', makeState()); // non-accepting state
	makeRegexT(S_WS, SPACE, S_WS);

	// Generates states for top-level domains
	// Note that this is most accurate when tlds are in alphabetical order
	for (let i = 0; i < tlds.length; i++) {
		makeChainT(S_START, tlds[i], makeNearDomainState(tk.TLD), makeDomainState);
	}

	// Collect the states generated by different protocls
	const S_PROTOCOL_FILE = makeDomainState();
	const S_PROTOCOL_FTP = makeDomainState();
	const S_PROTOCOL_HTTP = makeDomainState();
	const S_MAILTO = makeDomainState();
	makeChainT(S_START, 'file', S_PROTOCOL_FILE, makeDomainState);
	makeChainT(S_START, 'ftp', S_PROTOCOL_FTP, makeDomainState);
	makeChainT(S_START, 'http', S_PROTOCOL_HTTP, makeDomainState);
	makeChainT(S_START, 'mailto', S_MAILTO, makeDomainState);

	// Protocol states
	const S_PROTOCOL_SECURE = makeDomainState();
	const S_FULL_PROTOCOL = makeAcceptingState(tk.PROTOCOL); // Full protocol ends with COLON
	const S_FULL_MAILTO = makeAcceptingState(tk.MAILTO); // Mailto ends with COLON

	// Secure protocols (end with 's')
	makeT(S_PROTOCOL_FTP, 's', S_PROTOCOL_SECURE);
	makeT(S_PROTOCOL_FTP, ':', S_FULL_PROTOCOL);
	makeT(S_PROTOCOL_HTTP, 's', S_PROTOCOL_SECURE);
	makeT(S_PROTOCOL_HTTP, ':', S_FULL_PROTOCOL);

	// Become protocol tokens after a COLON
	makeT(S_PROTOCOL_FILE, ':', S_FULL_PROTOCOL);
	makeT(S_PROTOCOL_SECURE, ':', S_FULL_PROTOCOL);
	makeT(S_MAILTO, ':', S_FULL_MAILTO);

	// Register custom protocols
	const S_CUSTOM_PROTOCOL = makeDomainState();
	for (let i = 0; i < customProtocols.length; i++) {
		makeChainT(S_START, customProtocols[i], S_CUSTOM_PROTOCOL, makeDomainState);
	}
	makeT(S_CUSTOM_PROTOCOL, ':', S_FULL_PROTOCOL);

	// Localhost
	makeChainT(S_START, 'localhost', makeNearDomainState(tk.LOCALHOST), makeDomainState);

	// Everything else
	// DOMAINs make more DOMAINs
	// Number and character transitions
	makeRegexT(S_START, DIGIT, S_NUM);
	makeRegexT(S_START, LETTER, S_DOMAIN);
	makeRegexT(S_START, EMOJI, S_DOMAIN);
	makeRegexT(S_START, EMOJI_VARIATION, S_DOMAIN);
	makeRegexT(S_NUM, DIGIT, S_NUM);
	makeRegexT(S_NUM, LETTER, S_DOMAIN); // number becomes DOMAIN
	makeRegexT(S_NUM, EMOJI, S_DOMAIN); // number becomes DOMAIN
	makeRegexT(S_NUM, EMOJI_VARIATION, S_DOMAIN); // number becomes DOMAIN
	makeT(S_NUM, '-', S_DOMAIN_HYPHEN);

	// Default domain transitions
	makeT(S_DOMAIN, '-', S_DOMAIN_HYPHEN);
	makeT(S_DOMAIN_HYPHEN, '-', S_DOMAIN_HYPHEN);
	makeRegexT(S_DOMAIN, DIGIT, S_DOMAIN);
	makeRegexT(S_DOMAIN, LETTER, S_DOMAIN);
	makeRegexT(S_DOMAIN, EMOJI, S_DOMAIN);
	makeRegexT(S_DOMAIN, EMOJI_VARIATION, S_DOMAIN);
	makeRegexT(S_DOMAIN_HYPHEN, DIGIT, S_DOMAIN);
	makeRegexT(S_DOMAIN_HYPHEN, LETTER, S_DOMAIN);
	makeRegexT(S_DOMAIN_HYPHEN, EMOJI, S_DOMAIN);
	makeRegexT(S_DOMAIN_HYPHEN, EMOJI_VARIATION, S_DOMAIN);

	// Set default transition for start state (some symbol)
	S_START.jd = makeAcceptingState(tk.SYM);
	return S_START;
}

/**
	Given a string, returns an array of TOKEN instances representing the
	composition of that string.

	@method run
	@param {State} start scanner starting state
	@param {string} str input string to scan
	@return {{t: string, v: string, s: number, l: number}[]} list of tokens, each with a type and value
*/
export function run(start, str) {
	// State machine is not case sensitive, so input is tokenized in lowercased
	// form (still returns the regular case though) Uses selective `toLowerCase`
	// is used because lowercasing the entire string causes the length and
	// character position to vary in some non-English strings with V8-based
	// runtimes.
	const iterable = stringToArray(str.replace(/[A-Z]/g, (c) => c.toLowerCase()));
	const charCount = iterable.length; // <= len if there are emojis, etc
	const tokens = []; // return value

	// cursor through the string itself, accounting for characters that have
	// width with length 2 such as emojis
	let cursor = 0;

	// Cursor through the array-representation of the string
	let charCursor = 0;

	// Tokenize the string
	while (charCursor < charCount) {
		let state = start;
		let nextState = null;
		let tokenLength = 0;
		let latestAccepting = null;
		let sinceAccepts = -1;
		let charsSinceAccepts = -1;

		while (charCursor < charCount && (nextState = takeT(state, iterable[charCursor]))) {
			state = nextState;

			// Keep track of the latest accepting state
			if (state.accepts()) {
				sinceAccepts = 0;
				charsSinceAccepts = 0;
				latestAccepting = state;
			} else if (sinceAccepts >= 0) {
				sinceAccepts += iterable[charCursor].length;
				charsSinceAccepts++;
			}

			tokenLength += iterable[charCursor].length;
			cursor += iterable[charCursor].length;
			charCursor++;
		}

		// Roll back to the latest accepting state
		cursor -= sinceAccepts;
		charCursor -= charsSinceAccepts;
		tokenLength -= sinceAccepts;

		// No more jumps, just make a new token from the last accepting one
		// TODO: If possible, don't output v, instead output range where values ocur
		tokens.push({
			t: latestAccepting.t, // token type/name
			v: str.substr(cursor - tokenLength, tokenLength), // string value
			s: cursor - tokenLength, // start index
			e: cursor // end index (excluding)
		});
	}

	return tokens;
}

export { tk as tokens };

/**
 * Convert a String to an Array of characters, taking into account that some
 * characters like emojis take up two string indexes.
 *
 * Adapted from core-js (MIT license)
 * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js
 *
 * @function stringToArray
 * @param {string} str
 * @returns {string[]}
 */
 function stringToArray(str) {
	const result = [];
	const len = str.length;
	let index = 0;
	while (index < len) {
		let first = str.charCodeAt(index);
		let second;
		let char = first < 0xd800 || first > 0xdbff || index + 1 === len
		|| (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff
			? str[index] // single character
			: str.slice(index, index + 2); // two-index characters
		result.push(char);
		index += char.length;
	}
	return result;
}
