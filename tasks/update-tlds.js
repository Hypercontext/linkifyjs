const http = require('https'); // or 'https' for https:// URLs
const fs = require('fs');
const punycode = require('punycode/');

const tldsListUrl = 'https://data.iana.org/TLD/tlds-alpha-by-domain.txt';
const tldsjs = 'packages/linkifyjs/src/tlds.js';
let tldsListContents = '';


function createTrie(words) {
	const root = {};
	for (const word of words) {
		let current = root;
		for (const letter of word) {
			if (!(letter in current)) {
				current[letter] = {};
			}
			current = current[letter];
		}
		current.isWord = true; // underscore with 1 means word
	}
	return root;
}

function encodeTrieHelper(trie) {
	const output = [];

	for (const k in trie) {
		if (k === 'isWord') {
			output.push('_');
			continue;
		}
		output.push(k);
		output.push(...encodeTrieHelper(trie[k]));
		if (typeof output[output.length - 1] === 'number') {
			output[output.length - 1] += 1;
		} else if (output[output.length - 1] === '_') {
			output[output.length - 1] = 1;
		} else {
			output.push(1);
		}
	}

	return output;
}

function encodeTrie(trie) {
	return encodeTrieHelper(trie).join('');
}

function encodeTlds(tlds) {
	return encodeTrie(createTrie(tlds));
}

function decodeTlds(encoded) {
	const words = [];
	const stack = [];
	let i = 0;
	let digits = '0123456789';
	while (i < encoded.length) {
		let popDigitCount = 0;
		while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {
			popDigitCount++;
		}
		if (popDigitCount > 0) {
			words.push(stack.join(''));
			let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10);
			for (; popCount > 0; popCount--) {
				stack.pop();
			}
			i += popDigitCount;
			continue;
		}

		if (encoded[i] === '_') {
			words.push(stack.join(''));
		} else {
			stack.push(encoded[i]);
		}
		i++;
	}
	return words;
}


http.get(tldsListUrl, (response) => {
	console.log(`Downloading ${tldsListUrl}...`);
	response.on('data', (chunk) => { tldsListContents += chunk; });
	response.on('end', () => {
		console.log(`Downloaded. Re-generating ${tldsjs}...`);

		// NOTE: punycode versions of IDNs (e.g., `XN--...`) do not get included
		// in the TLDs list because these will not be as commonly used without
		// the http prefix anyway and linkify will already force-encode those.
		let tlds = [];
		let utlds = [];

		// NOTE: vermögensberater vermögensberatung are special cases because
		// they're the only ones that contain a mix of ASCII and non-ASCII
		// characters.
		const specialTlds = ['XN--VERMGENSBERATER-CTB', 'XN--VERMGENSBERATUNG-PWB'];
		const specialUtlds = specialTlds.map(tld => punycode.toUnicode(tld.toLowerCase()));

		for (const line of tldsListContents.split('\n').map(line => line.trim())) {
			if (!line || line[0] === '#' || specialTlds.includes(line)) { continue; }
			if (/^XN--/.test(line)) {
				utlds.push(punycode.toUnicode(line.toLowerCase()));
			} else {
				tlds.push(line.toLowerCase());
			}
		}
		tlds = tlds.concat(specialUtlds).sort();
		utlds = utlds.sort();

		console.log('Encoding...');
		const encodedTlds = encodeTlds(tlds);
		const encodedUtlds = encodeTlds(utlds);

		console.log('Testing decode...');
		const decodedTlds = decodeTlds(encodedTlds);
		console.assert(JSON.stringify(decodedTlds) === JSON.stringify(tlds), 'Invalid encode/decode routine');

		const jsFile = fs.openSync(tldsjs, 'w');
		fs.writeSync(jsFile, '// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY\n');
		fs.writeSync(jsFile, '// See update-tlds.js for encoding/decoding format\n');
		fs.writeSync(jsFile, `// ${tldsListUrl}\n`);

		// Write TLDs
		fs.writeSync(jsFile, 'export const encodedTlds = \'');
		fs.writeSync(jsFile, encodedTlds);
		fs.writeSync(jsFile, '\';\n');
		fs.writeSync(jsFile, '// Internationalized domain names containing non-ASCII\n');
		fs.writeSync(jsFile, 'export const encodedUtlds = \'');
		fs.writeSync(jsFile, encodedUtlds);
		fs.writeSync(jsFile, '\';\n');
		fs.closeSync(jsFile);

		console.log('Done');
	});
});
